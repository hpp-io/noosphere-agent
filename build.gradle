plugins {
    id "java"
    id "maven-publish"
    id "idea"
    id "eclipse"
    id "com.gorylenko.gradle-git-properties"
    alias(libs.plugins.spring.boot)
    id "jhipster.cucumber-conventions"
    id "jhipster.gatling-conventions"
    id "jhipster.spring-cache-conventions"
    id "jhipster.docker-conventions"
    id "jhipster.code-quality-conventions"
    id "org.liquibase.gradle"
    id "jhipster.node-gradle-conventions"
    // jhipster-needle-gradle-plugins - JHipster will add additional gradle plugins here
}

group = "io.hpp.noosphere.agent"
version = "0.0.1-SNAPSHOT"

description = ""

sourceCompatibility=17
targetCompatibility=17
assert System.properties["java.specification.version"] == "17" || "21" || "24"

ext {
    springProfiles = ""
    if (project.hasProperty("tls")) {
        springProfiles += ",tls"
    }
    if (project.hasProperty("e2e")) {
        springProfiles += ",e2e"
    }
}

repositories {
    // Local maven repository is required for libraries built locally with maven like development jhipster-bom.
    // mavenLocal()
    mavenCentral()
    // jhipster-needle-gradle-repositories - JHipster will add additional repositories
}

apply plugin: 'io.spring.dependency-management'

apply from: "gradle/liquibase.gradle"
// jhipster-needle-gradle-apply-from - JHipster will add additional gradle scripts to be applied here

if (project.hasProperty("prod")) {
    apply from: "gradle/profile_prod.gradle"
} else {
    apply from: "gradle/profile_dev.gradle"
}

if (project.hasProperty("war")) {
    apply from: "gradle/war.gradle"
}


idea {
    module {
        excludeDirs += files("node_modules")
    }
}

eclipse {
    sourceSets {
        main {
            java {
                srcDirs += ["build/generated/sources/annotationProcessor/java/main"]
            }
        }
    }
}

defaultTasks "bootRun"

springBoot {
    mainClass = "io.hpp.noosphere.agent.NoosphereAgentApp"
}

test {
    useJUnitPlatform()
    exclude "**/*IT*", "**/*IntTest*"
    testLogging {
        events 'FAILED', 'SKIPPED'
    }
    jvmArgs += '-Djava.security.egd=file:/dev/./urandom -Xmx512m'
    // uncomment if the tests reports are not generated
    // see https://github.com/jhipster/generator-jhipster/pull/2771 and https://github.com/jhipster/generator-jhipster/pull/4484
    // ignoreFailures true
    reports.html.required = false
    testLogging.exceptionFormat "full"
}

check.dependsOn integrationTest
task testReport(type: TestReport) {
    destinationDirectory = file("$buildDir/reports/tests")
    testResults.from(test)
}

task integrationTestReport(type: TestReport) {
    destinationDirectory = file("$buildDir/reports/tests")
    testResults.from(integrationTest)
}

gitProperties {
    failOnNoGitDirectory = false
    keys = ["git.branch", "git.commit.id.abbrev", "git.commit.id.describe"]
}

tasks.withType(com.gorylenko.GenerateGitPropertiesTask).configureEach {
  outputs.doNotCacheIf("Task is always executed") { true }
}

configurations {
    providedRuntime
    implementation.exclude module: "spring-boot-starter-tomcat"
}

dependencies {
    implementation "com.fasterxml.jackson.datatype:jackson-datatype-hppc"
    implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310"
    testImplementation("com.tngtech.archunit:archunit-junit5-api:${archunitJunit5Version}") {
        exclude group: "org.slf4j", module: "slf4j-api"
    }
    testRuntimeOnly("com.tngtech.archunit:archunit-junit5-engine:${archunitJunit5Version}") {
        exclude group: "org.slf4j", module: "slf4j-api"
    }
    implementation "io.micrometer:micrometer-registry-prometheus-simpleclient"
    implementation "jakarta.annotation:jakarta.annotation-api"
    implementation "org.apache.commons:commons-lang3"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.springframework.boot:spring-boot-configuration-processor"
    implementation "org.springframework.boot:spring-boot-loader-tools"
    implementation "org.springframework.boot:spring-boot-starter-actuator"
    implementation "org.springframework.boot:spring-boot-starter-aop"
    implementation "org.springframework.boot:spring-boot-starter-logging"
    implementation "org.springframework.boot:spring-boot-starter-mail"
    implementation "org.springframework.boot:spring-boot-starter-oauth2-resource-server"
    implementation "org.springframework.boot:spring-boot-starter-security"
    testImplementation "org.springframework.boot:spring-boot-starter-test"
    implementation "org.springframework.boot:spring-boot-starter-thymeleaf"
    implementation "org.springframework.boot:spring-boot-starter-undertow"
    modules {
        module("org.springframework.boot:spring-boot-starter-tomcat") {
            replacedBy("org.springframework.boot:spring-boot-starter-undertow", "Use Undertow instead of Tomcat")
        }
    }
    implementation "org.springframework.boot:spring-boot-starter-validation"
    implementation "org.springframework.boot:spring-boot-starter-web"
    testImplementation "org.springframework.boot:spring-boot-test"
    testImplementation "org.springframework.security:spring-security-test"
    implementation libs.jhipster.framework
    implementation libs.springdoc.openapi.starter.webmvc.api
    implementation "org.springframework.boot:spring-boot-starter-data-jpa"
    implementation "org.springframework.boot:spring-boot-starter-websocket"
    implementation "org.springframework.security:spring-security-data"
    implementation "org.springframework.security:spring-security-messaging"
    implementation "com.fasterxml.jackson.datatype:jackson-datatype-hibernate6"
    implementation "com.fasterxml.jackson.module:jackson-module-jaxb-annotations"
    implementation "com.zaxxer:HikariCP"
    implementation "org.hibernate.orm:hibernate-core"
    implementation "org.hibernate.validator:hibernate-validator"
    implementation "org.postgresql:postgresql"
    testImplementation "org.testcontainers:jdbc"
    testImplementation "org.testcontainers:junit-jupiter"
    testImplementation "org.testcontainers:postgresql"
    testImplementation "org.testcontainers:testcontainers"
    annotationProcessor "org.glassfish.jaxb:jaxb-runtime"
    annotationProcessor "org.hibernate.orm:hibernate-jpamodelgen"
    developmentOnly "org.springframework.boot:spring-boot-docker-compose"
    // jhipster-needle-gradle-dependency - JHipster will add additional dependencies here
    compileOnly 'org.projectlombok:lombok:1.18.32'
    annotationProcessor 'org.projectlombok:lombok:1.18.32'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'

    // Docker-Java 핵심 라이브러리
    implementation 'com.github.docker-java:docker-java:3.6.0'
    implementation 'com.github.docker-java:docker-java-transport-httpclient5:3.6.0'

    // Web3j dependencies
    implementation 'org.web3j:core:4.10.3'
    implementation 'org.web3j:crypto:4.10.3'
    implementation 'org.web3j:contracts:4.10.3'
    implementation 'org.web3j:utils:4.10.3'
    implementation 'org.web3j:abi:4.10.3'
    implementation 'org.web3j:codegen:4.10.3'
}

ext {
    // 처리할 컨트랙트 목록 (파일명 확장자 제외)
    selectedContracts = [
        'Router',
        'Coordinator',
        'DelegateeCoordinator',
        'WalletFactory',
        'Wallet',
        'SubscriptionBatchReader'
        // 필요한 컨트랙트만 추가
    ]

    // 또는 프로젝트 프로퍼티로 설정 (gradle 실행시 -PcontractNames=Contract1,Contract2)
    if (project.hasProperty('contractNames')) {
        selectedContracts = project.contractNames.split(',').collect { it.trim() }
    }
}

task generateWeb3jWrappers {
    description = 'Generate Web3j contract wrappers from selected Foundry artifacts'
    group = 'build'

    def foundryOutDir = file("./contract/out")
    def outputDir = file("src/main/java")
    def packageName = "io.hpp.noosphere.agent.contracts"
    def tempDir = file("build/tmp/web3j")

    inputs.dir(foundryOutDir)
    outputs.dir(outputDir)

    doLast {
        outputDir.mkdirs()
        tempDir.mkdirs()

        if (!foundryOutDir.exists()) {
            println "Foundry output directory not found: ${foundryOutDir.absolutePath}"
            println "Please run 'forge build' first in your contract directory"
            return
        }

        println "Selected contracts to process: ${selectedContracts}"

        selectedContracts.each { contractName ->
            def contractProcessed = false

            foundryOutDir.listFiles()?.each { contractDir ->
                if (contractDir.isDirectory()) {
                    def exactJsonFile = new File(contractDir, "${contractName}.json")
                    if (exactJsonFile.exists()) {
                        processContractFile(contractName, exactJsonFile, tempDir, outputDir, packageName)
                        contractProcessed = true
                        return
                    }


                    contractDir.listFiles()?.each { jsonFile ->
                        if (jsonFile.name == "${contractName}.json") {
                            processContractFile(contractName, jsonFile, tempDir, outputDir, packageName)
                            contractProcessed = true
                        }
                    }
                }
            }

            if (!contractProcessed) {
                println "Warning: Contract '${contractName}' not found in Foundry artifacts"
                println "Available contracts:"
                listAvailableContracts(foundryOutDir)
            }
        }
    }
}

def processContractFile(String contractName, File jsonFile, File tempDir, File outputDir, String packageName) {
    println "Processing contract: ${contractName} from ${jsonFile.absolutePath}"

    try {
        def jsonSlurper = new groovy.json.JsonSlurper()
        def contractJson = jsonSlurper.parse(jsonFile)

        def abi = contractJson.abi
        def bytecode = contractJson.bytecode?.object

        if (abi && bytecode) {
            // 임시 ABI와 bin 파일 생성
            def abiFile = new File(tempDir, "${contractName}.abi")
            def binFile = new File(tempDir, "${contractName}.bin")

            abiFile.text = groovy.json.JsonBuilder.newInstance(abi).toPrettyString()
            binFile.text = bytecode.startsWith('0x') ? bytecode.substring(2) : bytecode

            // Web3j wrapper 생성
            generateWrapper(contractName, abiFile, binFile, outputDir, packageName)

            println "✓ Generated wrapper for ${contractName}"
        } else {
            println "✗ Skipping ${contractName}: missing ABI or bytecode"
        }
    } catch (Exception e) {
        println "✗ Error processing ${contractName}: ${e.message}"
        e.printStackTrace()
    }
}

def listAvailableContracts(File foundryOutDir) {
    def availableContracts = []

    foundryOutDir.listFiles()?.each { contractDir ->
        if (contractDir.isDirectory()) {
            contractDir.listFiles()?.each { jsonFile ->
                if (jsonFile.name.endsWith('.json')) {
                    def contractName = jsonFile.name.replace('.json', '')
                    availableContracts << "${contractDir.name}/${contractName}"
                }
            }
        }
    }

    availableContracts.each { contract ->
        println "  - ${contract}"
    }
}

def generateWrapper(String contractName, File abiFile, File binFile, File outputDir, String packageName) {
    try {
        javaexec {
            classpath = configurations.runtimeClasspath
            main = 'org.web3j.codegen.SolidityFunctionWrapperGenerator'
            args = [
                '-a', abiFile.absolutePath,
                '-b', binFile.absolutePath,
                '-o', outputDir.absolutePath,
                '-p', packageName,
                '-c', contractName
            ]
        }
    } catch (Exception e) {
        println "Failed to generate wrapper for ${contractName}: ${e.message}"
        throw e
    }
}

selectedContracts.each { contractName ->
    task "generate${contractName}Wrapper" {
        description = "Generate Web3j wrapper for ${contractName} contract only"
        group = 'web3j'

        doLast {
            def foundryOutDir = file("./contract/out")
            def outputDir = file("src/main/java/io/hpp/noosphere/agent/web3j/contracts")
            def packageName = "io.hpp.noosphere.agent.web3j.contracts"
            def tempDir = file("build/tmp/web3j")

            outputDir.mkdirs()
            tempDir.mkdirs()

            def contractProcessed = false
            foundryOutDir.listFiles()?.each { contractDir ->
                if (contractDir.isDirectory()) {
                    contractDir.listFiles()?.each { jsonFile ->
                        if (jsonFile.name == "${contractName}.json") {
                            processContractFile(contractName, jsonFile, tempDir, outputDir, packageName)
                            contractProcessed = true
                        }
                    }
                }
            }

            if (!contractProcessed) {
                println "Contract '${contractName}' not found"
            }
        }
    }
}

task listFoundryContracts {
    description = 'List all available contracts from Foundry build output'
    group = 'web3j'

    doLast {
        def foundryOutDir = file("./contract/out")

        if (!foundryOutDir.exists()) {
            println "Foundry output directory not found. Run 'forge build' first."
            return
        }

        println "Available contracts in Foundry output:"
        listAvailableContracts(foundryOutDir)
    }
}

//generateWeb3jWrappers.dependsOn buildFoundryContracts
//compileJava.dependsOn generateWeb3jWrappers


task cleanResources(type: Delete) {
    delete "build/resources"
}

compileJava.dependsOn processResources
processResources.dependsOn bootBuildInfo
